**第十七章 MySQL复制**

**17.1 配置复制**

**17.1.1 基于二进制日志文件位置的复制配置概述**

**17.1.2 搭建基于二进制日志文件位置的复制**

**17.1.2.1 设置复制中源服务器的配置**

**17.1.2.2 设置从服务器的配置**

**17.1.2.3 为复制创建账户（在原服务器上）**

**17.1.2.4 获取源服务器上的二进制日志坐标**

**17.1.2.5 选择创建数据快照的方法**

**17.1.2.6 搭建从服务器**

**17.1.2.7 在从服务器上设置源服务器的配置**

**17.1.2.8 向一个复制环境中添加从服务器**

**17.1.3 使用全局事务标识符的复制**

**17.1.3.1 GTID格式和存储**

**17.1.3.2 GTID生命周期**

**17.1.3.3 GTID自动定位**

**17.1.3.4 搭建使用GTIDs的复制**

**17.1.3.5 使用GTIDs进行故障转移和横向扩展**

**17.1.3.6** 

**17.1.4 在线服务器上更改 GTID 模式**

**17.1.5 MySQL多源复制**

**17.1.6 复制和二进制日志参数和变量**

**17.1.7 常用复制管理任务**

**17.2 复制实现**

**17.2.1 复制方式**

**17.2.2 复制通道**

**17.2.3 复制线程**

**17.2.4 Relay Log中继日志和复制元数据存储库**

**17.2.5 服务器如何评估复制过滤规则**

**17.3 复制安全性**

**17.3.1 设置复制以使用加密连接**

**17.3.2 加密二进制日志文件和中继日志文件**

**17.3.3 复制特权检查**

**17.4 复制解决方案**

**17.4.1 使用复制进行备份**

**17.4.2 处理复制意外停止**

**17.4.3 监控基于行的复制**

**17.4.4 使用不同来源的复制和复制存储引擎**

**17.4.5 使用复制进行扩展**

**17.4.6 将不同的数据库复制到不同的副本**

**17.4.7 提高复制性能**

**17.4.8 故障转移期间的切换源**

**17.4.9 异步连接故障转移的切换源**

**17.4.10 半同步复制**

**17.4.11 延迟复制**

**17.5 复制笔记和提示**

**17.5.1 复制的特点和问题**

**17.5.2 MySQL版本之间的复制兼容性**

**17.5.3 升级复制体系**

**17.5.4 复制故障诊断**

**17.5.5 如何报告复制错误或问题**

复制可以使数据从一个MySQL数据库服务器（作为源服务器）复制到另一个或多个MySQL数据库服务器（作为从服务器）。复制默认是异步的；从服务器不需要永久的连接在源服务器上来接收更新。根据配置，你可以复制所有数据库、特定的数据库、或者一个数据库里面特定的表。

MySQL复制的优点包括：

- 扩展解决方案：在多个副本之间分担负载，以提高性能。在此环境下，所有的写操作和更新操作在源服务器上进行，读操作则可以在一个或多个从服务器上进行。这种模式可以改善写操作的性能（因为源服务器只负责更新操作），越来越多的从服务器就可以大幅度提高读操作的速度。
- 数据安全：由于从服务器可以暂停复制过程，因此可以在不损坏相应源数据的情况下在从服务器上运行备份服务。
- 分析：可以在源服务器上创建实时数据，而信息分析可以在从服务器上进行，不影响源服务器的性能。
- 远程数据分发：你可以利用复制创建数据的本地副本，供远程站点使用，无需永久访问源服务器。

有关如何在此类场景下如何使用复制的信息，见17.4 复制解决方案。

MySQL8.0支持不同方法的复制。传统方法是基于从源服务器的二进制日志文件中复制事件，要求在源服务器和从服务器之间同步它们的二进制文件和位置。基于全局事务标识符（GTIDs）的新方法是事务性的，所以不需要处理这些文件中的日志文件和位置信息，这极大简化了很多日常复制任务。只要所有的事务在源服务器上提交后同时也应用于从服务器，基于全局事务标识符（GTIDs）的复制就能保证源服务器和从服务器之间的一致性。更多关于全局事务标识符（GTIDs）和基于全局事务标识符（GTIDs）的复制，见17.1.3 基于全局复制标识符的复制。有关基于二进制日志文件位置的复制，见17.1 配置复制。



复制支持不同类型的同步方式。原始的复制是单程、异步的，一个服务器当作源服务器，另一个或多个服务器当作从服务器。这与NDB集群的同步复制形成鲜明对比，见23章 MySQL NDB Cluster8.0。在MySQL8.0中，除了支持异步复制，另外还支持半同步复制。在半同步复制下，直到至少一个从服务器确认已经收到并记录了事务的事件后，才会在返回执行事务的会话之前，在源块上进行提交（With semisynchronous replication, a commit performed on the source blocks before returning to the session that performed the transaction until at least one replica acknowledges that it has received and logged the events for the transaction;），见17.4.10 半同步复制。MySQL8.0还支持延迟复制，使从服务器故意落后于源服务器一定时间。见17.4.11 延迟复制。对于需要同步复制的情况，请使用NDB cluster。

有很多方法可以在服务器之间构建复制，最佳方法取决于你正在使用的数据和存储引擎类型。有关可用方法的更多信息见17.1.2 构建基于二进制日志文件位置的复制。

复制有两种核心方式，基于语句的复制（SBR）（复制整个SQL语句），和基于行的复制（RBR）（只复制更改的行）。你也可以用第三种，混合复制（MBR）。有关不同复制方式的更多信息见17.2.1 复制方式。

复制由一系列不同的选项和变量控制。更多信息见17.1.6 复制和二进制日志选项和变量。额外的安全措施可应用于复制拓扑，见17.3 复制安全性。

你可以用复制解决一系列的不用问题，包括性能、支持不同数据库的备份、以及作为缓解系统故障的解决方案的一部分。有关如何处理这些问题的信息，见17.4 复制解决方案。

有关在复制期间如何处理不同数据类型和语句的注释和提示，包括复制功能、兼容性、升级以及潜在问题和及其解决方案的细节，见17.5 复制注释和提示。有关复制新手经常提出的问题的答案，见17.2 附录A.14 MySQL8.0 FAQ：复制。

有关复制实现、复制如何工作、二进制日志的处理和内容、后台线程以及用来决定语句如何被记录和复制的规则的详细信息，见17.2 复制实现。

## 17.1 配置复制

本节描述如何配置MySQL所支持的不同类型的复制，包括复制环境所需要的设置和配置、包括创建一个新的复制环境的分步说明。本节的主要组成有：

- 有关构建一个或多个基于二进制日志文件位置的复制服务器的指南。17.1.2 搭建基于二进制日志文件位置的复制，涉及到服务器的配置，并提供了在源和副本之间复制数据的方法。
- 有关搭建一个或多个基于全局事务标识符的复制服务器的指南，17.1.3 基于全局事务标识符的复制，涉及到服务器的配置。
- 事件在二进制日志里用不同的方式进行记录。被成为基于语句的复制（SBR）和基于行的复制（RBR）。第三类，混合方式复制，使用SBR或RBR复制，酌情利用SBR和RBR方式的有点。不同方式的讨论，见17.2.1 复制方式。
- 适用于复制的不同选项和变量的详细信息，见17.1.6 复制和二进制日志选项和变量。
- 一旦开始，复制不需要太多的管理和监控。有关你要执行的常见任务的建议，见17.1.7 一般复制管理任务。

### 17.1.1 基于二进制日志文件位置的复制配置概述

本节描述基于二进制日志文件位置的MySQL服务器之间的复制方法，其中作为源服务器（数据库更改的地方）的MySQL实例将更新和更改写入二进制日志的事件。根据数据库正在记录的变化，二进制日志中的信息以不同的二进制方式存储。从服务器被配置为读取源服务器的二进制日志，并在从服务器上执行二进制日志中的事件。

每个从服务器都会收到一份二进制日志全部内容的副本。由从服务器决定二进制日志中的哪些语句应该被执行。除非另有说明，否则将在从服务器上执行源服务器二进制日志中的所有事件。如果需要，你可以将从服务器配置为执行适用于特定数据库或表的事件。

> **重要：不能将源配置为仅记录某些事件。**

每个从服务器都保存二进制日志坐标的记录：从源服务器读取和处理的文件名和位置。这意味着多个从服务器都可以连接到源服务器上，并执行同一个二进制日志的不同部分。因为是由从服务器控制此过程的，单个从服务器可以在不影响源服务器操作的情况下与源服务器连接或断开连接。此外，由于每个从服务器都记录了二进制日志的当前位置，因此对于从服务器来说可以断开连接、重新连接然后恢复处理。

源服务器和从服务器必须配置一个唯一的ID（使用server_id系统变量）。此外，从服务器必须配置有关源服务器主机名、日志文件名及其位置的信息。详细信息可以在从服务器的MySQL会话内使用change master to语句进行控制。详细信息会存储在从服务器的连接元数据存储库。（见17.2.4 中继日志和复制元数据存储库）

### 17.1.2 构建基于二进制日志文件位置的复制

本节描述了如何构建MySQL服务器以使用基于二进制日志文件位置的复制。有很多不同的方法都可以构建复制，具体点方法取决于你如何构建复制，以及在源服务器的数据库中是否已经有你想复制的数据。

> Tip
>
> 要部署多个MySQL实例，你可以利用InnoDB Cluster，可以帮你轻松的在MySQL Shell中管理一组MySQL服务器实例。InnoDB Cluster将MySQL组复制封装在一个编程环境中，使你能够轻松的部署MySQL实例集群以实现高可用。此外，InnoDB Cluster与MySQLRouter无缝连接，使你的应用程序无需编写自己的故障转移流程即可连接到集群。然而，对于不需要高可用的类似情况，你可以使用InnoDB ReplicaSet。MySQL Shell的安装说明可以在[这里](https://dev.mysql.com/doc/mysql-shell/8.0/en/mysql-shell-install.html)找到。

有一些通用任务是所有复制的共同点：

- 你必须确保源服务器上的二进制日志是打开的，并为源服务器配置一个唯一的server_id，需要重启服务器。见17.1.2.1 设置复制源服务器配置。
- 对于每一个要连接到源服务器上的从服务器，必须配置唯一的server_id，需要重启服务器。见17.1.2.2 设置从服务器配置。
- 为你的从服务器创建一个单独的用户，以便读取源服务器上的二进制日志进行复制时进行身份验证。见17.1.2.3创建复制用户
- 在创建数据快照或启动复制过程之前，要记录源服务器上二进制日志的当前位置。在配置从服务器时，你需要这个信息，以便从服务器知道从二进制日志的什么位置开始执行事件。见17.1.2.4 获取复制源服务器二进制日志坐标。
- 如果在源服务器上已经有数据，并想用它来同步从服务器，你需要创建一个数据快照，用来复制数据到从服务器上。你所使用的存储引擎会影响你创建快照的方式。如果用的MyISAM存储引擎，你必须在源服务器上停止处理语句，以获得读锁，然后获取当前二进制日志坐标并转储其数据，然后允许源服务器继续执行语句。如果不停止执行语句，转储的数据跟源服务器状态信息将不匹配，导致从服务器上的数据库不一致或损坏。有关复制MyISAM源的更多信息见17.1.2.4获取复制源服务器二进制日志坐标。如果你用的InnoDB存储引擎，你不需要读锁，足够长的事务足以传输数据快照。更多信息见15.19InnoDB和MySQL复制。
- 配置从服务器，以便连接到源服务器上，包括主机名、登录凭证以及二进制日志文件名和位置。见17.1.2.7在从服务器上设置源服务器配置。
- 根据系统，对源服务器和从服务器实施特定于复制的安全措施，见17.3复制安全。

> Note
>
> 以上设置过程需要super权限。如果没有此权限，你将无法使用复制。

配置完基本选项后，选择你的场景：

- 要为新安装的，没有数据的源服务器和从服务器进行设置，见17.1.2.6.1。
- 设置用现有MySQL服务器上的数据作为新源的复制，见17.1.2.6.2。
- 为现有的复制环境增加从服务器，见17.1.2.8向一个复制环境增加从服务器。

在管理MySQL复制服务器之前，阅读本章所有内容，并尝试13.4.1和13.4.2节的语句。还要熟悉17.1.6节中描述的复制启动选项。

#### 17.1.2.1 配置源服务器

要配置基于二进制日志文件位置的复制的源服务器，你必须确保二进制日志已经打开，并建立一个唯一的server_id。



每一个用于复制技术的服务器，都要配置一个唯一的server_id，此变量用来标识复制中的单个服务器，必须是1到223-1之间的数。MySQL8.0中server_id默认值是1，可以这样设置：

```
set global server_id=2;
```

你可以自由选择如何组织和选择server_id的值，但与复制拓扑中的其他服务器必须是不同的。请注意，如果之前为服务器ID设置了0的值（这是早期版本的默认值），则必须重新启动服务器，以使用新的非零服务器ID初始化源服务器。如果只是改变server_id的值，是不需要重启服务器的，除非配置有其他的改变。

源服务器需要二进制日志，因为二进制日志是从源服务器复制更改到从服务器的基础。二进制日志默认是开启的（log_bin系统变量值为ON）。--log-bin选项告诉服务器二进制日志文件用什么基名。建议你指定此选项，给二进制日志文件一个非默认的基名，如果主机名变了，你可以轻松的继续使用同样的二进制日志文件名（见附录B.3.7 MySQL中的已知问题）。如果之前使用--skip-log-bin选项在源服务器上禁用了二进制日志，必须在没有此选项的情况下重启服务器。

> Note
>
> 以下选项也会对源服务器产生影响：
>
> - 在一个使用InnoDN事务的复制体系中，为了最大程度的耐用性和一致性，你应该在源服务器的my.cnf文件中使用innodb_flush_log_at_trx_commit=1 和 sync_binlog=1 。
> - 确保skip_networking系统变量在源服务器上没有打开。如果网络瘫痪了，从服务器就不能与源服务器通信，复制就会失败。

#### 17.1.2.2 配置从服务器

每个从服务器都有一个唯一的server_id，由系统变量server_id来指定。如果你正在构建多个从服务器，每个从服务器都必须有唯一的server_id，与源服务器和其他从服务器要区分开。如果从服务器的server_id还未设置，或着当前值与源服务器或另一个从服务器存在冲突，你必须修改他。默认的server_id值是1。你可以通过下面的语句动态的修改server_id的值：

```
SET GLOBAL server_id = 21;
```

注意当server_id的值为0时，将阻止从服务器连接源服务器。如果server_id的值（在早起发行版中是默认值）之前被设置过，那你必须重启服务器，以便用新的非0值服务器ID初始化从服务器。另外，当只是改变了服务器ID时不需要重启服务器，除非你改变了其他配置。比如，服务器上的二进制日志被禁用了，你想为你的复制服务器重新开启，那就要重启服务器了。



如果你关闭了复制服务器，你可以编辑配置文件中的mysqld部分，来指定一个唯一的服务器ID，比如：

```
[mysqld]
server-id=12
```

所有服务器的二进制日志是默认开启的。从服务器上的二进制日志是不需要开启的。然而，从服务器上的二进制日志开启的话，就可以用来做数据备份和崩溃恢复。从服务器上的二进制日志还可以用在更复杂的复制拓扑中。比如，你可能想通过链式排列来构建复制服务器：

```
A -> B -> C
```

这里，A作为B的源服务器，B作为C的源服务器。为了做到这一点，B必须是源服务器也是从服务器。为了能将从A接收到的更新传递给C，B必须将其记录到二进制日志中。除了二进制日志记录外，这个复制拓扑还需要启用log_slave_updates系统变量。启用从服务器更新后，从服务器将‘从源服务器收到的并由从服务器的SQL线程执行的更新’写入从服务器自己的二进制日志。log_slave_audates系统变量是默认开启的。



如果你想禁用从服务器上的二进制日志或从服务器更新记录，你可以通过指定从服务器的--skip-log-bin和--log-slave-updates=OFF来做到。如果你想重新启用从服务器的这些功能，移除相关参数并重启服务器即可。

#### 17.1.2.3 为复制创建用户

每个从服务器用一个MySQL用户名和密码连接到源服务器，所以源服务器上必须有一个用户账号，以便从服务器用来连接。当你设置从服务器时，这个用户名通过CHANGE MASTER TO命令的MASTER_USER选项来指定。任何账号都可以用来执行这个操作，前提是授予他REPLICATION SLAVE特权。你可以选择为每个从服务器创建不同的账号，也可以用同一个账号连接到主服务器上。



尽管你不必专门为复制创建账号，但你应该知道复制用户名和密码都存储在复制连接元数据存储库mysql.slave_master_info的纯文本中（见17.2.4 复制元数据存储库）。因此，为了最小化损坏其他账号的可能性，你可能会想创建一个仅对复制过程有特权的单独账号，



CREATE USE语句可以创建一个新账号。用GRANT语句授予它复制的特权。如果你只是为了复制而创建一个账号，那这个账号只需要拥有REPLICATION SLAVE特权。比如设置一个新用户名“repl”，可以让他在example.com域名的任何主机连接到复制，可以在源服务器上执行这些语句：

```
mysql> CREATE USER 'repl'@'%.example.com' IDENTIFIED BY 'password';
mysql> GRANT REPLICATION SLAVE ON *.* TO 'repl'@'%.example.com';
```

更多有关控制用户账号的语句的信息，见13.7.1 账号管理语句。

> Important
>
> 如果你想通过一个用caching_sha2_password插件验证的用户账号连接到源服务器，你必须像17.3.1节 构建使用加密连接的复制 描述的那样设置一个安全连接，或者启用使用RSA密钥来支持密码交换的非加密连接。MySQL8.0创建新用户时caching_sha2_password验证插件是默认的（详细信息见 6.4.1.2 caching sha2可插拔验证）。如果你创建的或者用来复制的用户账号（通过MASTER_USER选项指定）用了这个验证插件，并且你没有使用安全连接，那你必须启用基于RSA密钥对的密码交换才能成功连接。

#### 17.1.2.4 获取复制源服务器二进制日志坐标

为了配置从服务器使得它能在正确的点开始复制过程，你需要记录下源服务器为二进制日志的当前坐标。

> Warning
>
> 这个过程用FLUSH TABLES WITH READ LOCK，来阻止InnoDB表的提交操作。

你如果计划关闭源服务器来创建数据快照，你可以选择性的跳过这个过程，而是将二进制日志索引的副本和数据快照存储在一起。在这种情况下，源服务器在重新启动时会创建一个进的二进制日志文件。所以，从服务器开始复制过程的源服务器的二进制日志坐标就是这个新文件的开始处，该文件是源服务器上在二进制日志索引文件中列出的文件的下一个二进制日志文件。



要获取源服务器二进制日志坐标，按照以下步骤：

1、通过用命令行客户端连接到源服务器上开启一个会话，然后执行FLUSH TABLES WITH READ LOCK语句刷新所有表，并阻止写语句。

```
mysql> FLUSH TABLES WITH READ LOCK;
```

> Warning
>
> 使执行FLUSH TABLES语句的客户端保持运行，以使读锁保持有效。如果退出客户端，锁将被释放

在源服务器上用另一个不同的会话，用SHOW MASTER STATUS确定当前二进制日志文件名和位置。

```
mysql > SHOW MASTER STATUS; 
+------------------+----------+--------------+------------------+
| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | 
+------------------+----------+--------------+------------------+
| mysql-bin.000003 | 73       | test         | manual,mysql     | 
+------------------+----------+--------------+------------------+
```

‘file’列显示了日志文件名，‘position’列显示了文件中的位置。在这个例子中，二进制日志文件是mysql-bin.000003，位置是73。记下这些值。当你设置从服务器时会用上它们。它们的意思就是从服务器开始处理源服务器上的更新的复制坐标。



如果源服务器以前在运行时禁用了二进制日志，则用SHOW MASTER STATUS或mysqldump --naster-data语句显示出来的日志文件名和位置是空的。这种情况下，你稍后在指定源服务器的二进制日志文件和位置时需要使用的时空字符串(' ')和4。



现在你有了能够使从服务器在正确位置开始从源服务器的二进制日志文件和位置读取以开始复制过程所需要的信息。



下一步取决于在源服务器上你是否有已经存在的数据。从以下选项中选一个：

- 如果在开始复制之前，已经存在需要同步到从服务器上的数据，让客户端持续运行，以便保留锁。这会防止任何进一步的修改，以便复制到从服务器上的数据与源服务器是同步的。继续看17.1.2.5节 选择数据快照的方法。
- 如果你正在构建一个新的源服务器和从服务器的组合，你可以退出第一个会话以释放读锁。见17.1.2.6节 设置从服务器 17.1.2.6.1用新的源服务器和从服务器构建复制。

#### 17.1.2.5 选择数据快照的方法

如果源服务器数据库有已经存在的数据，那么有必要把这个数据拷贝到从服务器上。有两种方法可以转储源服务器上的数据。下面两节描述了可行的选项。



在以下选项中，选择合适的转储数据库的方法：

- 使用mysqldump工具创建你想复制的所有数据库的转储文件。这是推荐的方法，特别是使用InnoDB存储引擎时。
- 如果你的数据库存储在二进制可移植文件中，你可以将原始数据文件拷贝到从服务器。这比使用mysqldump转储并在从服务器上导入转储文件更高效，因为跳过了重新执行insert语句时经常性更新索引的操作。但使用InnoDB存储引擎时，不推荐这个方法。

> Tip
>
> 要部署多个MySQL实例，你可以利用InnoDB Cluster，可以帮你轻松的在MySQL Shell中管理一组MySQL服务器实例。InnoDB Cluster将MySQL组复制封装在一个编程环境中，使你能够轻松的部署MySQL实例集群以实现高可用。此外，InnoDB Cluster与MySQLRouter无缝连接，使你的应用程序无需编写自己的故障转移流程即可连接到集群。然而，对于不需要高可用的类似情况，你可以使用InnoDB ReplicaSet。MySQL Shell的安装说明可以在[这里](https://dev.mysql.com/doc/mysql-shell/8.0/en/mysql-shell-install.html)找到。

**17.1.2.5.1 使用mysqldump创建数据快照**

要创建一个已经存在的源服务器数据库的数据的快照，可以使用mysqldump工具。数据转储完成后，在开始复制过程之前，将这个数据导入从服务器。



下面的例子将所有的数据库转储到dbdump.db文件，并包含--master-data选项，它可以自动附加上CHANGE MASTER TO语句，正是在一个复制中开始复制过程所需要的。

```
shell> mysqldump --al--databases --master-data > dbdump.db
```

> Note
>
> 如果你不用--master-data选项，那你有必要在一个单独的绘画中手工锁定所有的表。见17.1.2.4 获取复制源服务器二进制日志坐标。

可以使用mysqldump工具将某些数据库排除在转储中。如果你想选择转储哪些数据库，不要用--all-databases，选择以下选项之一：

- 排除数据库中所有的表，使用--ignore-table选项。
- 你想转储特定名字的数据库，用--databases选项。

> Note
>
> By default, if GTIDs are in use on the source (gtid_mode=ON), mysqldump includes the GTIDs from the gtid_executed set on the source in the dump output to add them to the gtid_purged set on the replica. If you are dumping only specific databases or tables, it is important to note that the value that
>
> is included by mysqldump includes the GTIDs of all transactions in the gtid_executed set on the source, even those that changed suppressed
>
> parts of the database, or other databases on the server that were not included in the partial dump. Check the description for mysqldump's --set-gtid- purged option to find the outcome of the default behavior for the MySQL Server versions you are using, and how to change the behavior if this outcome is not suitable for your situation.
>
> 默认情况下，如果源服务器上使用了GTID（gtid_mode=ON），

更多信息，见4.5.4 mydqldump-一个数据库备份程序。



要导入数据，要么转储文件拷贝到从服务器，或者远程连接到从服务器时从源服务器访问文件。

**17.1.2.5.2 使用原始数据文件创建数据快照**

本节介绍如何使用构成数据库的原始文件创建数据快照。使用具有复杂的缓存和日志算法的存储引擎的表利用这个方法时，需要额外的步骤，来获得一个完美的“时间点”快照：即使你获得了一个全局读锁，初始复制命令也可能会忽略缓存信息和日志记录更新。存储引擎如何应对取决于它的崩溃恢复能力。



如果你用的是InnoDB表，你可以使用MySQL企业备份组件中的mysqlbackup命令来生成一致的快照。此命令记录了要在副本上使用的快照相对应的日志名称和偏移量。MySQL企业备份是一个商业产品，包含在MySQL企业订阅中。详细信息见30.2节 MySQL企业备份概述。



如果源服务器和从服务器上ft_stopword_file、ft_min_word_len或ft_max_word_len变量具有不同的值，而且你正在复制具有全文索引的表，那么此方法是不可靠的。



假设以上的例外不适用于你的数据库，可以用冷备份创建一个InnoDB表的可靠的二进制快照：对MySQL服务器执行slow shutdown，然后手动复制数据文件。



如果你的MySQL数据文件存在一个单一的文件系统里，那么你在创建一个MyISAM表的原始数据快照时，你可以使用标准文件复制工具比如cp或copy，远程复制工具比如scp或rsync，归档工具比如zip或tar，或者文件系统快照工具比如dump。如果你只想复制特定的表，那就只拷贝与这些表相关的文件。对于InnoDB存储引擎，所有数据库的所有表都存储在系统表空间文件里面，除非你启用了innodb_file_per_table选项。



下面的文件是复制所不需要的：

- 与mysql数据库有关的文件。
- 从服务器的连接元数据存储库文件master.info，如果使用；现在不建议使用此文件（见17.2.4节 中继日志和复制元数据存储库）。
- 源服务器的二进制日志文件，二进制日志索引文件除外，如果你准备用这个文件定位复制所需的源服务器二进制日志坐标。
- 任何中继日志文件。



根据你是否使用InnoDB表，请选择以下选项其一：

如果你使用InnoDB表，并且为了获得与原始数据快照最一致的结果，请在过程中关闭源服务器，如下：

1、获取读锁并得到源服务器的状态，见17.1.2.4节 获取复制源服务器二进制日志坐标。

2、在另一个单独的会话中关闭源服务器。

```
shell> mysqladmin shutdown 
```

3、制作MySQL数据文件的副本，下面的例子展示了一般的方法，你需在他们之中选一个：

```
shell> tar cf /tmp/db.tar ./data
shell> zip -r /tmp/db.zip ./data
shell> rsync --recursive ./data /tmp/dbdata
```

4、重启源服务器

如果你没有使用InnoDB表，你可以按照以下步骤从源服务器上获得系统快照，无需关闭源服务器：

1、获取读锁，并得到源服务器的状态，见17.1.2.4 获取复制源服务器二进制日志坐标。

2、制作MySQL数据文件的副本，下面的例子展示了一般的方法，你需在他们之中选一个：

```
shell> tar cf /tmp/db.tar ./data
shell> zip -r /tmp/db.zip ./data
shell> rsync --recursive ./data /tmp/dbdata
```

3、在你获取读锁的客户端中，释放锁：

```
mysql> unlock tables;
```

创建数据库的归档或副本后，在开始复制过程之前将文件拷贝到每个从服务器。

#### 17.1.2.6 设置从服务器

本节介绍如何设置从服务器。开始之前，确保如下工作已完成：

- 使用必要的配置属性配置源服务器，见17.1.2.1 设置复制源服务器配置。
- 已经获取源服务器状态信息，或在关闭服务器期间数据快照的源服务器二进制日志索引文件的副本。见17.1.2.4 获取复制源服务器二进制日志坐标。
- 在源服务器上，释放了读锁。

```
mysql> unlock tables;
```

- 在从服务器上，编辑了MySQL配置，见17.1.2.2 设置从服务器配置。

下面的步骤取决于你是否有已存在数据要导入从服务器。更多信息见17.1.2.5节 获取数据快照的方法。从以下选择其一：

- 如果你没有要导入的数据库快照，见17.1.2.6.1 在新源服务器和从服务器上构建复制。
- 如果你有要导入的数据库快照，见17.1.2.6.2 构建已经存在数据的复制。

**17.1.2.6.1 在新源服务器和从服务器上搭建复制**

当没有之前数据库的快照要导入时，配置从服务器以从新源服务器开始复制。



要在源服务器和新从服务器之间构建复制：

1、启动从服务器。

2、在从服务器上执行CHANGE MASTER TO语句，以设置源服务器配置，见17.1.2.7节 在从服务器上设置源服务器配置。



在每个从服务器上执行上述步骤。



如果你正在构建新服务器，但已有另一个服务器数据库存在的转储，并且要加载到复制配置中，也可以使用此方法。通过将数据加载到新源服务器，数据会自动复制到从服务器。（意思就是配置好复制环境后，将别的数据库的转储加载到当前复制环境的源服务器上，就可以自动复制到从服务器上了）



如果你在构建复制环境时，想用另一个存在的数据库服务器上的数据创建（填充）新的源服务器，就在这个新的源服务器上运行从该服务器生成的转储文件，数据库更新会自动传播到从服务器上。

```
shell> mysql -h source <fulldb.dump
```

**17.1.2.6.2 使用现有数据设置复制**

当你构建已经存在数据的复制环境时，在开始复制之前，要将快照从源服务器传输到从服务器。将数据导入从服务器的过程取决于你是如何在源服务器上创建数据快照的。



> Tip
>
> 要部署多个MySQL实例，你可以利用InnoDB Cluster，可以帮你轻松的在MySQL Shell中管理一组MySQL服务器实例。InnoDB Cluster将MySQL组复制封装在一个编程环境中，使你能够轻松的部署MySQL实例集群以实现高可用。此外，InnoDB Cluster与MySQLRouter无缝连接，使你的应用程序无需编写自己的故障转移流程即可连接到集群。然而，对于不需要高可用的类似情况，你可以使用InnoDB ReplicaSet。MySQL Shell的安装说明可以在[这里](https://dev.mysql.com/doc/mysql-shell/8.0/en/mysql-shell-install.html)找到。



> Note
>
> 如果复制源服务器上，或者你要通过拷贝现有从服务器以创建新从服务器的这个现有从服务器上，具有任何的预定的事件，在启动新从服务器之前，确认已经在新从服务器上禁用他们。如果一个已经在源服务器上已经运行的事件在从服务器上运行，重复操作会导致错误。事件调度器（Event Scheduler）是由系统变量event_scheduler控制的，在MySQL8.0中是默认开启的，所以当新从服务器启动时，在原来的服务器上的活跃事件会在新从服务器上默认运行。要停止新从服务器上所有事件的运行，请在新从服务器上将系统变量event_scheduler设置为OFF或者DISABLED。或者，你可以使用ALTER EVENT语句将单个事件设置为DISABLE或DISABLE ON SLAVE，以阻止他们在新从服务器上运行。你可以在服务器上使用SHOW语句或者information_schem数据库的EVENTS表，将事件列出来。更多信息见17.5.1.16节 复制调用功能。

作为一这种方式创建新从服务器的替代方法，MySQL server的克隆插件可以将所有数据和复制设置从现有从服务器传输到克隆。这种方法的使用指南，见5.6.7.6节 克隆复制。



请按以下步骤设置已经存在数据的复制：

1、如果你使用MySQL server的克隆插件创建一个现有从服务器的克隆，那么数据会自动传输。若没有用克隆插件，用以下方法中的一种将数据导入从服务器。

a、如果你用的mysqldump创建的快照，启动从服务器之前，确保复制没有使用--skip-slave-option选项来启动，从MySQL8.0开始，是      skip_slave_start系统变量。然后导入dmp文件。

```
shell> mysql < full.dbmp
```

b、如果你是用原始数据文件创建的快照，将数据文件提取到从服务器的数据目录。比如：

```
shell> tar xvf dbdump.tar
```

你可能需要对文件设置权限和所有权，使从服务器可以访问并修改他们。然后启动从服务器，确保复制启动时没有用--skip-slave-start选项，从MySQL8.0开始，是系统变量skip-slave-start。

2、使用源服务器的复制坐标配置从服务器。这可以告诉从服务器二进制日志文件和文件中复制开始时的位置。此外，还要用源服务器的登录凭证和主机名配置从服务器。更多关于CHANGE REPLICATION SOURCE | CHANGE MASTER TO语句的信息，见17.1.2.7 在从服务器上设置源服务器配置信息。

3、通过START REPLICA | SLAVE语句启动复制线程。



执行完以上过程后，从服务器就会连接到原服务器上，并且将复制自快照拍摄以来发生在源服务器上的所有更新。如果任意原因导致复制不可用，错误信息将会写入从服务器的错误报告。



从服务器使用记录在它的连接元数据存储库和适当的元数据存储库中的信息，根据已经处理的源服务器二进制日志量。从MySQL8.0开始，这些存储库默认情况下就是mysql数据库中名字为slave_master_info和slave_relay_log_info的表。不要移动或编辑这些表，除非你清楚的知道你在做什么，并且要对复制有深入理解。即使在这种情况下，你最好还是用CHANGE REPLICATION SOURCE TO | CHANGE MASTER TO语句来改变复制参数。从服务器会根据语句中指定的值自动更新复制元数据存储库。更多信息见17.2.4 中继日志和复制元数据存储库。

> Note
>
> 复制连接元数据存储库中的内容将覆盖在命令行或配置文件my.cnf中指定的一些服务器选项。详细信息见17.1.6节 复制和二进制日志选项和变量。

一份数据快照就足够多个从服务器使用。要想搭建额外的从服务器，使用同样的源服务器快照，并按照上述过程的从服务器部分进行操作。

#### 17.1.2.7 在从服务器上设置源服务器配置

要想搭建从服务器连接到源服务器上的复制，需要用必要的连接信息配置从服务器。为此，在从服务器上执行CHANGE REPLICATION SOURCE TO语句（从MySQL8.0开始）或者CHANGE MASTER TO语句（MySQL8.0.23之前），将选项值替换为与系统相关的实际值：

```
mysql> CHANGE MASTER TO
    ->     MASTER_HOST='source_host_name',
    ->     MASTER_USER='replication_user_name',
    ->     MASTER_PASSWORD='replication_password',
    ->     MASTER_LOG_FILE='recorded_log_file_name',
    ->     MASTER_LOG_POS=recorded_log_position;

Or from MySQL 8.0.23:
mysql> CHANGE REPLICATION SOURCE TO
    ->     SOURCE_HOST='source_host_name',
    ->     SOURCE_USER='replication_user_name',
    ->     SOURCE_PASSWORD='replication_password',
    ->     SOURCE_LOG_FILE='recorded_log_file_name',
    ->     SOURCE_LOG_POS=recorded_log_position;
```

> Note
>
> 复制不能使用Unix套接字文件。你必须能够使用TCP/IP连接到源服务器。

CHANGE REPLICATION SORCE TO | CHANGE MASTER语句还有其他的选项。比如可以使用SSL搭建安全复制。选项的完整列表，包括字符串值允许的最大长度选项信息，见13.4.2.1 CHANGE MASTER TO 语句。

> Important
>
> 正如17.1.2.3节描述的，如果你没有使用安全连接，并且在SOURCE_USER | MASTER_USER选项中提到的用户账号用caching_sha2_password插件（MySQL8.0默认）进行身份验证，你必须指定在CHANGE REPLICATION SOURCE TO | CHANGE MASTER TO语句中指定SOURCE_PUBLIC_KEY_PATH | MASTER_PUBLIC_KEY_PATH 或者 GET_SOURCE_PUBLIC_KEY | GET_MASTER_PUBLIC_KEY选项，以启用基于RSA密钥对的密码交换。

#### 17.1.2.8 向复制环境中添加从服务器

你可以向已经存在的复制配置中添加另一个从服务器，而不用关闭源服务器。为此，你可以通过复制已有的从服务器的数据目录来搭建新的从服务器，并为新从服务器设置不同的server_id（用户指定）和服务器UUID（启动时产生的）。

> Note
>
> 如果复制源服务器上，或者你要通过拷贝现有从服务器以创建新从服务器的这个现有从服务器上，具有任何的预定的事件，在启动新从服务器之前，确认已经在新从服务器上禁用他们。如果一个已经在源服务器上已经运行的事件在从服务器上运行，重复操作会导致错误。事件调度器（Event Scheduler）是由系统变量event_scheduler控制的，在MySQL8.0中是默认开启的，所以当新从服务器启动时，在原来的服务器上的活跃事件会在新从服务器上默认运行。要停止新从服务器上所有事件的运行，请在新从服务器上将系统变量event_scheduler设置为OFF或者DISABLED。或者，你可以使用ALTER EVENT语句将单个事件设置为DISABLE或DISABLE ON SLAVE，以阻止他们在新从服务器上运行。你可以在服务器上使用SHOW语句或者information_schem数据库的EVENTS表，将事件列出来。更多信息见17.5.1.16节 复制调用功能。

作为一这种方式创建新从服务器的替代方法，MySQL server的克隆插件可以将所有数据和复制设置从现有从服务器传输到克隆。这种方法的使用指南，见5.6.7.6节 克隆复制。



如果不用克隆，可按以下步骤复制一个现有从服务器：

1、停止复制，并记录从服务器状态信息，特别是源服务器二进制日志文件和中继日志文件的位置。你可以在performance_schema数据库的复制表（见27.12.11 performance_schema数据库复制表）或者通过输入SHOW REPLICA | SLAVE STATUS 来查看从服务器状态：

```
mysql> STOP SLAVE;
mysql> SHOW SLAVE STATUS\G
Or from MySQL 8.0.22:
mysql> STOP REPLICA;
mysql> SHOW REPLICA STATUS\G
```

2、关闭现有从服务器：

```
shell> mysqladmin shutdown
```

3、将现有从服务器的数据目录拷贝到新从服务器，包括日志文件和中继日志文件。你可以通过使用tar或winzip创建归档来做到，也可以使用cp或rsync等工具直接拷贝。

> Important
>
> - 开始拷贝前，确认现有从服务器所有相关的文件都已经存储到数据目录下。比如InnoDB系统表空间、undo表空间、redo日志可能存储在替代位置。InnoDB表空间文件和file-per-table表空间可能是在其他目录创建的。从服务器的二进制日志和中继日志可能在他们自己的不目录，而不在数据目录中。通过为现有从服务器设置的系统变量来查看并找出你曾经指定过的任何可替代的目录。如果找到了，也要拷贝这些目录。
> - 拷贝过程中，如果如果文件已经用于复制元数据存储库（见17.2.4节 中继日志和复制元数据存储库），确认你同时也把这些文件从现有从服务器拷贝到了新从服务器。如果表已经用于存储库，那么表就在数据目录里，这在MySQL8.0中是默认的。
> - 完成拷贝后，删除新从服务器上数据目录上auto.cnf文件的副本，这样，新从服务器就用一个不同的生成的服务器UUID启动。服务器的UUID必须是唯一的。

当添加新从服务器时经常遇到的一个问题是，新从服务器会失败，并显示一些列警告和错误信息，如下：

```
071118 16:44:10 [Warning] Neither --relay-log nor --relay-log-index were used; so
replication may break when this MySQL server acts as a replica and has his hostname
changed!! Please use '--relay-log=new_replica_hostname-relay-bin' to avoid this problem.
071118 16:44:10 [ERROR] Failed to open the relay log './old_replica_hostname-relay-bin.003525'
(relay_log_pos 22940879)
071118 16:44:10 [ERROR] Could not find target log during relay log initialization
071118 16:44:10 [ERROR] Failed to initialize the master info structure
```

如果relay_log系统变量没有被指定，那这种情况就可能会发生，因为中继日志文件在他们的文件名里面会包含主机名。如果relay_log_index系统变量没有使用，中继日志索引文件也会出现这样的错误。



为了避免这个问题，应将新从服务器上的relay_log系统变量设置为与现有从服务器相同。如果这个选项在现有从服务器上没有明确的设置，请使用**existing_replica_hostname**-relay-bin。如果这不可能，将现有从服务器的中继日志索引文件拷贝到新从服务器上，并在新从服务器上设置relay_log_index系统变量，来匹配现有从服务器上使用的系统变量。如果这个变量在现有从服务器上没有明确的设置，请使用**existing_replica_hostname**-relay-bin.index。或者，你已经按照本节剩余的步骤尝试过启动新从服务器了，并且遇到了上面描述过的错误，那么请执行下面的步骤：

a、如果你还没做这些，在新从服务器上执行STOP REPLICA | SLAVE。

​           如果你已经再次启动了现有从服务器，在现有从服务器上执行STOP        REPLICA | SLAVE。

b、复制现有从服务器的中继日志索引文件目录到新从服务器的中继日志                索引文件，并确保覆盖了当前文件中的所有目录。

c、执行本节中其余的步骤。



4、拷贝完之后，重启现有从服务器。



5、在新从服务器上，编辑配置，并为新从服务器分配一个唯一源服务器和其他现有服务器都没使用的的server_id（使用系统变量server_id）。



6、启动新从服务器，通过指定--skip-slave-start（从MySQL8.0开始，是skip_slave_start系统变量）确保复制尚未开始。使用performance_schema中的表或者执行SHOW REPLICA | SLAVE STATUS 以确认与现有从服务器相比，新从服务器具有正确的设置。同时显示server_id和服务器UUID，并验证他们对新从服务器来说是正确的和唯一的。



7、通过执行START REPLICA | SLAVE语句，启动复制线程。新从服务器现在使用它的连接元数据存储库里面的信息来启动复制过程。

### 17.1.3 使用全局事务标识符的复制

本节说明基于事务的使用全局事务标识符的复制。当使用GTIDs时，每个事务在原来的服务器上被提交时都可以被识别和追踪，并应用到从服务器上。这意味着使用GITDs时，当启动一个新从服务器或新源服务器遇到故障时，没有必要引用这些文件中的日志文件或位置，这极大简化了这些任务。因为基于GTID的复制是完全基于事务的，因此确定源服务器和从服务器是否一致是很简单的。只要所有的事务在源服务器上和从服务器上都提交了，两者之间就保持了一致性。你可以在GTID中使用基于语句的或者基于行的复制（见17.2.1节 复制格式）。但是为了获得最佳效果，建议使用基于行的格式。



GTIDs总是保存在源服务器和从服务器之间。这意味着你始终可以通过检查二进制日志，来决定源服务器的任何事务应用到任何从服务器上。此外，一旦具有给定GTID的事务在给定服务器上提交了，任何具有相同GTID的事务都会被服务器忽略。因此，在源服务器上提交的事务最多只能在从服务器上应用一次，这有助于实现一致性。



本节讨论以下主题：

- 如何定义和创建GTIDs，以及如何在MySQL服务器中表示（见17.1.3.1节 GTID格式和存储）。
- GTID的生命周期（见17.1.3.2节 GTID生命周期）。
- 用于使用GRID同步从服务器和源服务器的自动定位函数（见17.1.3.3 GTID自动定位）。
- 搭建和启动基于GTID的复制的一般步骤（见17.1.3.4 搭建使用GTID的复制）。
- 使用GTID时提供新复制服务器的建议方法（见17.1.3.5节 ）。
- 使用基于GTID的复制时，应该注意的限制和约束（见17.1.3.6节 使用GTID的复制的限制）。
- 可用于GTID的存储函数（见17.1.3.7节 操作GTID的存储函数示例  ）。



更多与基于GTID的复制有关的MySQL服务器选项和变量，见17.1.6.5节 全局事务标识符系统变量，也见12.19节 全局事务标识符（GTIDs）使用的函数，这一节描述了MySQL8.0支持的用于GTIDs的SQL函数。

#### 17.1.3.1 全局事务标识符格式和存储

一个全局事务标识符（GTID）是由原始服务器（源服务器）上每一个提交过的事务创建的并与每个事务相关联的一个唯一的标识符。这个标识符不只是在他的原始服务器上是唯一的，在整个复制拓扑中的所有服务器上也是唯一的。



GTID分配区分了客户端事务和复制事务，前者在原服务器上提交，后者在从服务器上再现。当一个客户端事务在源服务器上提交后，只要这个事务被写进了二进制日志，就会为他分配一个新的GTID。客户端事务保证具有单调递增的GTIDs，生成的数字之间没有间隔。如果客户端事务没有写进二进制日志（比如，因为事务被过滤掉，或者事务是只读的），则不会在它的原始服务器上分配GTID。



复制的事务会保留他在原始服务器上分配的GTID。复制的事务在执行之前GTID都是存在的，即使复制的事务没有写到从服务器的二进制日志，或者在从服务器上被过滤了，GTID也会持续存在。MySQL系统表mysql.gtid_executed用来保存应用到MySQL服务器的所有事务被分配的GTID，但存储在当前活跃二进制日志文件中的事务除外。



GTIDs的自动跳过功能（auto-skip）意思是在源服务器上提交的事务只能在从服务器上应用一次，这保证了数据一致性。一旦一个给定的GTID的事务在给定的服务器上提交后，该服务器将忽略任何具有相同GTID的事务的执行尝试。不会出现错误，并且事务中的任何语句都不会执行。



如果一个具有给定GTID的事务在源服务器上开始执行了，但是还没有提交或者回滚，则在具有相同GTID块的服务器上任何启动并行事务的尝试。服务器不会开始执行并发事务，也不会将控制权交还给客户端。一旦第一次尝试事务的提交或回滚，被同一GTID阻塞的并发会话可能会继续。如果第一次尝试回滚了，一个并发会话将继续尝试执行事务，其他的被同一GTID阻塞的并发会话会继续阻塞。如果第一次尝试提交了，所有的并发会话将不再被阻塞，将会自动跳过（auto-skip）事务中的所有语句。



一个GTID用一对坐标表示，用一个冒号隔开：

```
GTID = source_id:transaction_id
```

source_id标识原始服务器。一般源服务器的server_uuid就是用来做这个。transaction_id是按照事务在源服务器上提交的顺序确定的有序数字。比如，第一个提交的事务的transaction_id是1 ，那么在同一个原始服务器上提交的第十个事务的transaction_id就是10。事务在GTID中的序号不可能为0。比如，在UUID为3E11FA47-71CA-11E1-9E33-C80AA9429562的服务器上第23个提交的事务的GTID为：

```
3E11FA47-71CA-11E1-9E33-C80AA9429562:23
```



事务的GTID在mysqlbinlog程序的输出中被展示，在performance_schema数据库的复制状态表中他用来标识单个事务，比如replication_applier_status_by_worker表。保存在gtid_next系统变量（@@GLOBAL.gtid_next）中的值是一个单独的GTID。

**
**

**17.1.3.1.1 GTID集**

GTID集就是由一个单独的GTIDs或者一个范围的GTIDs组成的集合。GTID集在MySQL服务器上有几种用法。比如，gtid_executed和gtid_pured系统变量存储的值是GTID集。START REPLICA | SLAVE语句的子句UNTIL   SQL_BEFORE和UNTIL SQL_AFTER_GTIDS可以用于使从服务器处理事务到GTID集的第一个GTID，或者直到GTID集的最后一个GTID。内置函数GTID_SUBSET()和GTID_SUBTRACT()需要GTID集作为输入。



来自同一个原始服务器的GTIDs范围值，可以合并在一个表达式里：

```
3E11FA47-71CA-11E1-9E33-C80AA9429562:1-5
```

上面的例子表示UUID为3E11FA47-71CA-11E1-9E33-C80AA9429562的MySQL服务器的第一到第五个事务。源自同一个服务器的多个GTIDs值或GTIDs范围值也可以包含在一个表达式里，并用分号隔开：

```
3E11FA47-71CA-11E1-9E33-C80AA9429562:1-3:11:47-49
```

GTID集可以包含单个GTIDs值或GTIDs范围值的任意组合，而且可以包含源自不同服务器的GTIDs。下面的例子展示了一个从服务器上gtid_executed系统变量（@@GLOBAL.gtid_executed）存储的GTID集，这个从服务器应用了多个源服务器的事务。

```
2174B383-5441-11E8-B90A-C80AA9429562:1-3, 24DA167-0C0C-11E8-8442-00059A3C7B00:1-19
```

当GTID集从服务器变量返回时，UUID按字母顺序排列，数字间隔合并，并按升序排列。



GTID集的语法如下：

```
gtid_set:
    uuid_set [, uuid_set] ... 
  | ''
    
  uuid_set: uuid:interval[:interval]...
    
  uuid: hhhhhhhh-hhhh-hhhh-hhhh-hhhhhhhhhhhh
  
h:
    [0-9|A-F]
  
interval: 
    n[-n]
    (n >= 1)
```

**
**

**17.1.3.1.2 mysql.gtid_executed表**

GTIDs存储在mysql数据库的gtid_executed表中。对于每一个GTID或GTIDs的集合，表中的每一行表示的是原始服务器的UUID、集合的开始和结束事务ID；对于只代表一个单独GTID的一行，后面两列的值是一样的。



mysql.gtid_executed表（如果他尚未存在）在服务器安装或更新时用CREATE TABLE语句创建，如下：

```
CREATE TABLE gtid_executed (
    source_uuid CHAR(36) NOT NULL,
    interval_start BIGINT(20) NOT NULL,
    interval_end BIGINT(20) NOT NULL,
    PRIMARY KEY (source_uuid, interval_start)
)
```

> Warning
>
> 与其他MySQL系统表一样，不要尝试创建或修改这个表。



mysql.gtid_executed表用于MySQL服务器的内部使用。当从服务器的二进制日志被禁用时，它使从服务器可以使用GTID；当二进制日志丢失时，它可以保留GTID的状态。注意，若执行RESET MASTER，mysql.executed表将被删除。



当gtid_mode变量的值是ON或者ON_PERMISSIVE时，GTIDs才会存入mysql.executed表。如果二进制日志被禁用了（log_bin的值是OFF），或者log_slave_updates（值为OFF）被禁用了，服务器在事务提交时将属于每个事务的GTID连同该事务一起存储在mysql.gtid_executed表中。此外，该表会以用户可配置的速率定期压缩，见17.1.3.1.3 mysql.gtid_execyted表压缩。



如果二进制日志启用了（log_bin的值为ON），从MySQL8.0.17开始（仅适用于InnoDB存储引擎），服务器以与“二进制日志或从服务器更新日志（log_slave_updates）被禁用时为每个事务在提交时存储其GTID的方法”相同的方法更新mysql.gtid_executed表。然而，在MySQL8.0.17之前，对于其他引擎，只有在二进制日志轮换时或者服务器关闭时，服务器才会更新mysql.executed表。此时，服务器将“所有写进之前二进制日志的事务”的GTIDs写入mysq.gtid_executed表。这种情形适用于MySQL8.0.17之前的源服务器，或MySQL8.0.17之前的启用二进制日志的从服务器，或使用InnoDB以外的存储引擎的服务器，它会产生以下后果：(mysql.executed表更新不及时)

- 如果服务器意外停止，当前二进制日志文件中的GTIDs集没有保存到mysql.executed表中。在恢复期间，这些GTID从二进制日志文件添加到mysql.executed表中，以便复制能够继续。例外情况是，如果服务器启动时禁用了二进制日志（使用了--skip-log-bin或--disable-log-bin选项）。这种情况下，服务器不能访问二进制日志文件，无法恢复GTIDs，所以复制没法启动。
- mysql.executed表并未保存所有已执行事务的完整记录。该信息由系统变量gtid_executed的全局值提供。在MySQL8.0.17之前的除InnoDB以外的其他存储引擎，在MySQL服务器中总是使用@@GLOBAL.gtid_executed变量（在每次提交后更新）表示GTID的状态，而不是查询mysql.gtid_executed表。



即使服务器在只读或超级只读模式下，MySQL服务器也可以写入mysql.executed表。在MySQL8.0.17之前，这确保了二进制日志可以在这些模式下轮换。

如果无法访问mysql.executed表进行写操作，而且二进制日志文件因为达到最大文件大小（max-binlog-size）以外的原因进行轮换了，那么当前的二进制日志文件就会继续被使用。错误信息返回给请求轮换的客户端，并且在服务器上记录警告。

如果不能访问mysql.executed进行写操作，并且二进制日志文件达到了最大文件大小，服务器的响应取决于binlog_error_action变量的设置。如果设置了IGNORE_ERROR，服务器会记录错误，二进制日志也会停止记录，如果设置了ABORT_SERVER，服务器会关闭。

**17.1.3.1.3 mysql.executed表压缩**

随着时间的推移，mysql.executed表可能会填充很多行，这些行引用了来自同一服务器的单个GTID，其事务ID构成一个范围，类似于以下所示：

```
+--------------------------------------+----------------+--------------+
| source_uuid                          | interval_start | interval_end |
|--------------------------------------+----------------+--------------|
| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 37             | 37           |
| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 38             | 38           |
| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 39             | 39           |
| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 40             | 40           |
| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 41             | 41           |
| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 42             | 42           |
| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 43             | 43           |
...
```

为了节省空间，MySQL服务器可以通过将每组此类行替换为横跨整个事务标识符间隔的一行周期性的压缩mysql.executed表，像这样：

```
+--------------------------------------+----------------+--------------+
| source_uuid                          | interval_start | interval_end |
|--------------------------------------+----------------+--------------|
| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 37             | 43           |
...
```

服务器使用一个名字为thread/sql/compress_gtid_table的专用前台线程执行压缩。这个线程不会在SHOW PROCESSLIST命令的输出中显示，但可以在performance_schema.threads表中查看，像下面这样：

```
mysql> SELECT * FROM performance_schema.threads WHERE NAME LIKE '%gtid%'\G *************************** 1. row ***************************
          THREAD_ID: 26
               NAME: thread/sql/compress_gtid_table
               TYPE: FOREGROUND
     PROCESSLIST_ID: 1
   PROCESSLIST_USER: NULL
   PROCESSLIST_HOST: NULL
     PROCESSLIST_DB: NULL
PROCESSLIST_COMMAND: Daemon
   PROCESSLIST_TIME: 1509
  PROCESSLIST_STATE: Suspending
   PROCESSLIST_INFO: NULL
   PARENT_THREAD_ID: 1
               ROLE: NULL
       INSTRUMENTED: YES
            HISTORY: YES
    CONNECTION_TYPE: NULL
       THREAD_OS_ID: 18677
```



当服务器启用二进制日志时，此压缩方法是不用的，而是在每一次二进制日志轮换时才会压缩mysql.executed表。然而，当服务器禁用二进制日志时，/thread/sql/compress_gtid_table线程处于休眠状态，直到特定数量的事务被执行了，才会醒来执行mysql.executed表的压缩。然后又会休眠，直到相同数量的事务执行完，再次醒来执行压缩，无限期重复此循环。表压缩之前执行的事务数量，和压缩率，由gtid_executed_compress_period系统变量的值进行控制，将其值设为0意味着此线程一直处于休眠状态，不会进行表的压缩。



从MySQL8.0.17开始，InnoDB事务通过一个与非InnoDB事务不同的单独的进程写入mysql.gtid_executed表。这个进程由另一个不同的线程innodb/clone_gtid_thread控制。该GTID持久性线程按组收集GTIDs，把他们刷新到mysql.executed表中，并压缩该表。如果服务器的InnoDB事务和非InnoDB事务混合在一起，并分别写入mysql.executed表，则compress_gtid_table线程的压缩会影响GTID持久性线程的工作，并降低它的效率。为此，从MySQL8.0.17开始，建议将gtid_executed_compression_period变量设为0，使compress_grid_table线程永不被激活。



从MySQL8.0.23以来，gtid_executed_compression_period默认值为0，InnoDB事务和非InnoDB事务都由GTID持久化线程写入mysql.executed表。



在MySQL8.0.17之前，可以使用gtid_executed_compression_period的值默认1000，意思是每执行1000个事务，对该表进行一次压缩，你也可以选一个可替换的值。在这些发行版中，如果你将其值设为零，并禁用二进制日志，则mysql.executed表不会被压缩，如果这样，你应该为可能需要增加磁盘空间的情况做准备。



当一个服务器实例启动时，如果gtid_executed_compression_period设置为一个非0值，并启动thread/sql/compress_gtid_table线程，在大多数服务器配置中，将对表mysql.gtid_executed进行压缩。在一个启用二进制日志的MySQL8.0.17服务器中，压缩是由二进制日志启动轮换的事实触发的。从MySQL8.0.20开始，压缩是由线程启动触发的。在中间版本中，启动时不会进行压缩。



#### 17.1.3.2 GTID生命周期

GTID的生命周期包含以下步骤：

1、一个事务在源服务器上执行并提交。然后这个事务被分配一个GTID，这个                 GTID由源服务器的UUID和服务器尚未使用的最小的非零事务序号组成。GTID被写入源服务器的二进制日志（立即在日志中位于事物本身之前）。如果一个客户端事务没有写入二进制日志（比如，可能因为事务被过滤了，或者事务是只读的），那它不会被分配GTID。



2、如果为事务分配了GTID，则在事务提交时，通过将此GTID写入二进制日志中事务的开始处（作为Gtid_log_event），以原子方式持久保存此GTID。每当二进制日志轮换或服务器关闭时，服务器都会将写入先前二进制日志文件的事务的GTID写入mysql.executed表。



3、如果为事务分配了GTID，通过将其加入到系统变量gtid_executed（@@GLOBAL.gtid_executed）的GTIDs集中，从而以非原子方式（在事务提交后的很短时间内）将GTID外部化。此GTID集包含所有已提交的GTID事务集合的描述，它在复制中作为一个符记，表示服务器的状态。启用二进制日志后（源服务器所要求的），这个位于gtid_executed系统变量中的GTIDs的集合是已经执行的事务的完整记录，但mysql.gtid_executed表不是，因为最新历史记录还在当前二进制日志文件中。



4、当二进制日志数据已经传播到从服务器并存入其中继日志后（该过程使用的建立机制，见17.2节 复制实现），从服务器会读取这个GTID，并将其grid_next系统变量的值设为此GTID。这告诉从服务器必须使用此GTID来登记下一个事务。重点注意，从服务器在会话上下文中设置了gtid_next。



5、从服务器将确认尚无线程拥有gtid_next中GTID的所有权，以处理此事务。在处理事务之前，首先通过读取并检查复制的事务的GTID，从服务器不只可以保证先前没有相同的事务已经在从服务器上执行，还能保证没有其他会话已经读取此GTID但还没有提交相关的事务。因此，如果多个客户端同时尝试执行同一个事务，服务器只让他们中的一个执行，这就解决了这个问题。从服务器的gtid_owned系统变量（@@GLOBAL.gtid_owned）显示当前正在使用的每个GTID和拥有它的线程ID。如果GTID已经使用了，也不会发生错误，auto-skip功能将用来忽略这个事务。



6、如果该GTID尚未使用，从服务器将会执行这个复制过来的事务。因为gtid_next系统变量已经被设置为源服务器已经分配的GTID，所以从服务器不会尝试为该事务生成一个新的GTID，而是使用存储在gtid_next中的GTID。



7、如果从服务器上启用了二进制日志，则在事务提交时，通过将此GTID写入二进制日志中事务的开始处（作为Gtid_log_event），以原子方式持久保存此GTID。每当二进制日志轮换或服务器关闭时，服务器都会将写入先前二进制日志文件的事务的GTID写入mysql.executed表。



8、如果从服务器上禁用了二进制日志，则通过直接将GTID写入mysql.gtid_executed，以原子方式持久保存此GTID。MySQL向事务附加一条语句，将GTID插入mysql.gtid_executed表中。从MySQL8.0开始，这个操作对DDL语句和DML语句都是原子性的。这种情况下，mysql.executed表就是已经应用到从服务器上的事务的完整记录。



9、复制的事件在从服务器上提交后的很短时间内，通过将GTID加入到系统变量gtid_executed的GTIDs的集合中，从而以非原子方式将GTID外部化。同样对于源服务器，这个GTID集包含了所有已提交的GTID事务的描述。如果从服务器上禁用了二进制日志，mysql.gtid_executed表也是应用到从服务器上的事务的完整记录。如果从服务器启用了二进制日志，意味着有些GTIDs只记录在二进制日志中，gtid_executed系统变量中的GTIDs集合是唯一的完整记录。



在源服务器上被完全过滤掉的客户端事务不会分配GTID，因此他们不会添加到grid_executed系统变量的事务集合，也不会添加到mysql.gtid_executed表。然而，在从服务器上被完全过滤掉的复制的事务的GTIDs会保留下来。如果从服务器启用了二进制日志，被过滤掉的事务将会作为Gtid_log_event写入二进制日志，然后是一个仅包含BEGIN和COMMIT语句的空事务。如果禁用了二进制日志，被过滤掉的事务的GTID会写入mysql.executed表。保留被过滤掉的事务的GTID，可确保mysql.executed表和grid_executed系统变量中的GTID集合可以被压缩。还可以确保，如果从服务器重新连接到源服务器，不会再次检索被过滤掉的事务，见17.1.3.3节 GTID Auto-Positioning自动定位 的描述。



在一个多线程的从服务器上，事务可以并行执行，所以复制的事务可能会无序提交（除非设置slave_preserve_commit_order=1）。当发生这种情况时，gtid_executed系统变量中的GTIDs集合会包含有间隔的多个GTID范围值。（在一个源服务器上或者单线程从服务器上，都是无间隔的单调递增的GTIDs。）多线程从服务器上的GTID值间隔只会出现在最近应用的事务中，并随着复制的进行将被填满。当使用STOP REPLICA | SLAVE语句干净利落地停止复制线程是，正在进行的事务将被应用，所以间隔会被填满。在诸如服务器故障或使用KILL语句终止复制线程的关机事件中，间隔可能会保留。



**17.1.3.2.1 What changes are assigned a GTID?什么改变会分配GTID？**

典型的情况是服务器为提交的事务生成了一个新的GTID。然而，除了事务以外，GTID也可以分配给其他的改变，而且在某些情况下，一个事务可以分配多个GTIDs。



每一个写入二进制日志的数据库改变（DDL or DML）都会分配一个GTID，这包括自动提交的改变，或使用BEGIN、COMMIT、START TRANSACTION语句进行提交的改变。数据库的创建、改变或删除，以及非表数据库对象比如存储过程、函数、触发器、事件、视图、用户、角色、授予权限的创建、改变、删除操作都会分配GTID。



非事务更新和事务更新一样也会分配GTID。此外，对于一个非事务更新，当尝试写入二进制日志缓存时，发生了磁盘写入错误，二进制日志中的一个间隔因此而产生，则为生成的事故日志事件分配GTID。



当一个表被二进制日志中生成的语句自动删除时，会为这条语句分配GTID。当从服务器开始应用刚刚启动的源服务器的事件时，以及使用基于语句的复制（binlog_format=STATEMENT）和打开了临时表的用户会话断开连接时，临时表会被自动删除。使用MEMORY存储引擎的表在服务器启动后首次访问时被自动删除，因为在关机期间可能有行丢失。



当一个事务没有写入其原始服务器的二进制日志时，服务器不会为他分配GTID。这包括被回滚的事务、原始服务器二进制日志禁用期间执行的事务，无论是全局的（服务器配置中指定--skip-log-bin选项）还是会话的（设置@@SESSION.sql_log_bin=0）。这还包括使用基于行的复制（binlog_format=ROW）时，那些无操作（no-op）的事务。